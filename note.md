初始化
```
npm init
```
安装包依赖
```
npm install three
```
运行
```
npm run dev
或者
yarn dev
```

窗户里侧看是看不见的；
门把手没有与门合在一块（包括会议室的门、入口的玻璃门）；
门把手之间有异常的联动；
门的旋转轴需要修改（有厚度的门建议改成打开一侧的轴）；
椅子的把手部门没有贴材质；
pointArr1=[
    115,0,82,
    130,-15,-6,
    17,-15,-6,
    17,-15,13,
    -66,-15,12,
    -80,-15,-12,
    -45,-15,-90,
    122,-15,-87,
    122,-15,62,
    90,-15,62
]
 pointArr2 = [
        115, 0, 82,
        62.2, -15, 50,
        31.2, -15, 50,
        31.2, -15, 62,
        -51, -15, 62,
        -51, -15, 63.5,
        -38,-15,63.5,
        -38,-15,43,
        -45,-15,43,
        -45,-15,50,
        -108,-15,50,
        -121,-15,90,
        72,-15,90,
        72,-15,50,
    ];

//快速定位
定位点：
[207,29,-3],   // 东侧概览
[150,-5,-50],  // C楼
[-120,-10,70], // 会议室A108后门
[-35,0,49],    // 教工之家
[-50,-15,62],  //A108







#### 感悟心得

说来也难以相信，一个月前，我还是对JavaScript一窍不通，那时，我甚至不知道一句话的结尾加不加分号(;)有啥区别。
那时的我，天天摸鱼，看着恩惠她们认真查资料，写文档，看着宇哥亲力亲为地去电子楼实地拍照取景、搜集材料，我只能从天天打游戏的老马身上找到一点归属感（恼）。
当宇哥将最小化的A108模型交付到我的手中时，一股压力与责任悄然降临。我要如何导入这个模型，如何实现交互，如何渲染，一系列问题涌现在我的脑海里。
纵使很难，我也要去做，别人可以依赖我，而我又去依赖谁呢？
从最原生的JavaScript开始学起？显然时间不允许，帮宇哥他们的项目也没有慢吞吞地去学习springmvc，还不是直接从项目本身入手（这里还是要感谢尚硅谷的优质ssm项目和细心的教程视频）。
于是我重新看起了B站的threejs的教程，虽然教得不如尚硅谷，但勉强还是带我入门了js技术。学完了一些基本的东西后我便着急准备上手了。代码就一行一行写吧，反正视频里的老师也没有多少格式，当时的我是这么想的。
从三要素（场景，相机，渲染器）到小方块的引入，都没啥问题，当时我以为我凭着Java的一点基础，js也能很快上手——直到宇哥和我讨论了模型的导入问题。
白皮书上写的是用objloader和mtlloader分别导入，我导入后却发现啥都看不见，将模型打印输出在控制台又有结果，顿时有了找bug的疲惫感。
后来宇哥提醒我，模型不只有obj，还有fbx（物体和材质是关联在一起的），我于是用fbxloader尝试着导入模型。初次导入，外加大小的缩放，终于能展示模型了，不过是纯黑色的。
“你这怎么这么黑，不开灯啊？”我恍然大悟，忘了加灯光了。
至此，模型能看见了，但问题又出现了，有些材质显示不了，如何是好？我仔细观察，发现椅子的颜色是有的——那是最基本的蓝色。
我于是采取了一种临时的折中方法，即先把所有物体涂上最基本的颜色，不再是纯黑，把最小化模型先展示出来，之后的材质再想办法。

但这种方法总归看着不是很高级的样子，我一边想着交互的事，一边寻求解决方案。

我仔细想了一下：fbx的模型在windows自带的3D查看器（包括vscode的模型查看插件）里能够显示材质，是因为3D查看器自动对当前文件夹做了解析，找到了模型对应的材质，并且贴了上去，所以我需要做的，还是通过代码逻辑，将材质手动地与模型的物体进行匹配。

这期间我有想过再原路返回，还是用白皮书里的那个OBJLoader和MTLLoader，然而白皮书上零零碎碎的代码片段在当时的我看来，根本不理解，这个问题就一直搁置着。

一日我又跑去看B站的教程，发现后面有一章是材质的讲解，在其中我了解到模型是由物体（object）和材质（material）组成的，没有材质的物体就是一个透明虚拟的看不见的东西，而材质（material）里面除了基本的颜色（color）外，还有一个map（贴图）属性，这个属性需要赋一个texture类型的值，而根据老师的讲解，texture类型的值，其本质就是一张图片！

之前宇哥常讲的贴图，我一直以为就是材质（material）本身，但更仔细的理解其实应该是材质表面那一层映射（map）上去的纹理（texture），而纹理的导入也十分简单——只需在纹理加载器（TextureLoader）的驱动下，填入图片的地址即可。

我迫不及待地找了一张图片尝试了一下，果然，网页中的黄色小方块变成了用纹理精致包装的小木箱。

我自信地告诉宇哥——尽管贴材质，我都可以导进去，那时我第一次有了突破瓶颈的感觉。

在动态交互实现的过程中，我在B站和CSDN遨游，接触了很多技术，其中包括gsap动画库，帧刷新函数方法、tween动画库等。这些技术各有特点，也都在我编写代码的过程中出现过，迭代过，派上用场过。

首先登场的是==gsap动画库==，这是在B站学到的最早的动画技术。其基本原理是将特定对象的某个属性值做修改，并且可以控制整个方法花费的时间，那么这两个基本功能结合起来就可以做一个简单的动画效果——比如对相机的position属性的x属性进行变化，再设定一个持续时间，例如5s，那么相机就可以在x轴上进行平移，实现一个动态的效果。

——这便是最初的A108模型外侧相机环绕的动态效果的由来。

不过我在具体实现的过程中，发现相机永远看着模型的正中央，当时我设法通过在运动中修改相机的lookAt方法来改变相机的朝向，然而并没有什么卵用——后来我才知道是轨道控制器（OrbitControls）在作祟，因为轨道控制器在帧刷新函数中不断调用update方法，导致我每次将镜头旋转的一瞬间（大概16ms）后，update方法被调用，相机便又盯着中央轨道看了。

==帧刷新函数==的动态方法是在漫游路线那块被使用的。当时我还依赖于gsap动画库实现漫游效果，但写起来十分麻烦。

因为这个过程中需要解决一个路线转弯的问题，也可以说是不同路线段如何关联到一起，期初我十分天真地找好了各个拐角处的坐标点，直接写了若干行代码，以为程序会按照我的意愿，在一行持续时间3s的代码执行完后，才开始执行下一行持续时间5s的代码。

然而实际情况是相机以非常诡异的轨迹不知道移动到哪去了，最后停留在了一个莫名其妙的地方。这时我才意识到：这些代码是先后执行的，只是间隔时间太短了——短到我无法察觉，就像是同时开始运行一样。也对，代码执行起来怎么可能会无缘无故地进行数秒的漫长等待呢？

不会无缘无故，那就给它一个逻辑——then()函数，在前面一段代码执行完毕之后再开始执行其中的内容，这个功能很好地满足了我当前的需求，只是写起来很麻烦——我需要一层套一层地调用then函数，有几个拐角点我就需要调用几次，而且我还使用了匿名函数()=>{}，一下子这些小括号、大括号纷纷出现，搞得我晕头转向，不知道哪个是哪个的结尾。而且如果要做得逼真一点，加上拐角处镜头的转向效果，那么嵌套量将会翻倍，到时候代码界面将十分恐怖。

有时候我们很容易将一件简单的事想得过于复杂了，我到CSDN上搜索，发现了一个很类似的案例——用人物模型进行三维空间的路线巡游，这不专业对口了。赶紧学习人家的技术，于是便有了帧刷新函数的动画调用。

我们知道动画都是由一帧一帧的画面连续播放组合而成的，这就是帧刷新函数的原理。而利用帧刷新函数实现动画的具体原理是：根据路线上的几个关键点生成一条曲线，然后将曲线分成一系列连续的点，从第一个点开始，每次调用帧刷新函数的时候，让相机向前移动若干个点，这样能保持相机一直在曲线上，只要切分地足够细并且刷新得足够快，就能够形成动画的效果。

这个东西的好处在于不需要再使用繁琐的gsap配合then函数的方法，直接生成一条漫游曲线，控制曲线切分的点的数量即可（由于是曲线，所以在转弯的过程中难免会有超过或不足90°的情况，并不是标准的直角转弯，但瑕不掩瑜，这样的效果已经很不错了）。

至于==tween动画库==的引入，纯粹是因为我不想再编写gsap繁琐的代码，同时又在CSDN多次看到tween的字眼，于是开始学习起了第三门动画技术。

tween结合了前两者的优点，既可以方便地控制动画的持续时间，又可以通过调用update方法将动画与帧刷新函数结合到一起，关键tween在逻辑上封装地更加抽象，也就更加具有普适性，当然从其基本语法来看，要实现相同的简单功能，比起gsap需要多写一点代码，不过好在其灵活，可以用相对较少的代码做到很多gsap无法轻易完成的高难度动作。

至此便是我在实现网页模型交互学习过程中的三个阶段，实际的写代码过程还会有很多需要考虑的地方。其中最主要（最痛苦）的是每加入一个新的技术，就要考虑代码的上下文是否需要更改，是否会与之前的技术产生冲突，逻辑上如何修改才能自洽之类的问题。

尤其是对于帧刷新函数，经历了这么久的相处，我对这个东西可以说是深有体会。因为在运行的过程中我们需要不断调用帧刷新函数，不然网页就是一张静态图片，是根本动不了的。这个不断调用的性质决定了帧刷新函数的特殊性——放入其中的代码片段如果不加以限制，就会无止境地执行下去。

打个比方，就像是一个无限容量的水库，如果开启了总闸门，里面的水就会汹涌泛滥而出，这可能会造成无法控制的局面。所以我需要做的，就是将一个总的闸门分为几个小闸门，在特定条件下开启某个或某些闸门，然后当条件完成后再及时地关闭闸门，这样才能流出理想的水量，流到目标的地方。

如何添加“小闸门”？很简单，用一个布尔类型的变量（通常称为flag标签），再辅以一些条件判断的语句，一个“闸门”就完成了，然后我们在需要调用函数的地方设置这些布尔变量的值，就可以实现对帧刷新函数的控制。

回忆完了对动画调用的过程，还有一些其他的东西需要补充。

==贴纹理==。

之前我实现了贴纹理的操作后，兴高采烈了一段时间，但那时的我还是太天真了，我不知道后续实际开发中的坑到底有多深。那时，我面对的模型还只是一个小方块，还只有一个单独的材质（material），后来我发现了模型里面原来还有多材质的物体（这也可以理解，一个贩卖机只有正面需要贴图，其他5个面都搞成灰色即可，但这也决定了贩卖机本身需要两种不同的材质），于是我将贴材质的部分分为了单材质和多材质两类进行操作：对于单材质是直接贴纹理，对于多材质是遍历其中的每一个材质，找到材质名对应的那个材质，再贴纹理。

==旋转门==。

旋转门的做法还在A108时期就有开始尝试了。这期间我见过各种各样的旋转——绕着几何中心自转的、横着在平面内转的、不绕长边绕短边转的、一个往外一个往里转的......究其原因是因为物体的旋转轴（也可以说是建模时定义的中心点）没有定义好，这里还是要感谢宇哥事无巨细地将几乎每一个门的旋转轴都调整到合适的位置。调整完旋转轴后还没完，我发现我的代码写的是每次旋转90°，但门每次并没有旋转90°，甚至关门的时候没有完全合得上。我在控制台仔细分析了门的rotation属性，发现它们的初始的y值并不是0，而是会有1-2度的偏差，这也就能解释为什么门差一点没关上的现象了。而且这不能完全归因于建模本身，因为网页展示也会对模型位置的计量出现一些小的偏差，这样的误差是避免不了的。知晓原因后，我想了个办法，我决定将错就错，如果一开始偏了1度，那么我就干脆保持这1度的偏差，让门在1度的基础上旋转90度，然后再回转90度回到1度。我不能为了一个小小的数值就放弃整个模型的一致完整性，在这种情况下，控制台输出的1度的偏差就是对的，如果硬是改成0度的标准旋转角度，就是与大多数背道而驰，就是违背统一，就该被消灭掉。关键在实现的过程中，又出现了一个小细节——初始值和当前值的小数点的位数不相同，也就导致这两者在数值上并不是完全相等——这个小细节我愣是找了很久才发现，当初写完代码觉得没有问题，但门就是不动，不知道错误出现在哪里，结果最后还是坏在了数学上。我做了一个简单的处理，用取整函数（round）结合一些小技巧对值做了一个保留两位小数的操作，从而解决了这个问题。至此，门的开关功能得以实现。

==快捷键的设置==。

话说有一日我又在测试模型，测试漫游路线时偶然想起之前提到的播放暂停功能，我点击了测试按钮，生效了，但我总觉得有点不对劲。结合在B站刷了两年半视频的经历，我发现当前的网页交互少了一个重要的东西——快捷键。当初学习时只记得老师讲了一个窗口添加响应事件的功能，没仔细学，但依稀记得里面有个关于键盘响应的事件，于是尝试着输入了一下key，结果跳出来三个选项：keydown、keypress以及keyup事件（这里不细讲，反正用keypress就对了）。但是这个窗口怎么知道我按下的是哪个键呢，这不得加个判断语句？哎，这一搜才发现，原来键盘上的每个键都是由对应的键编码（keyCode）的，所以我们只需要对事件返回值的keyCode属性的值进行条件判断，满足哪个值就调用自己之前定义好的某个方法即可。然后在界面的按钮后都加上快捷键提示，一个快捷键功能就完成了。（顺带一说，每一个键加了Shift后会有不同的keyCode，A和a对应的keyCode是**不一样的**）。

这期间我发现了（其实是被安利了）一个好用的主题vuesion，拿给恩惠看，不过她还是一如既往地喜欢白色，对黑色的主题不感兴趣。

不过主题的作用不止是视觉的改变，更重要的是高亮提示的功能，即不同的代码部分以不同的颜色表示，这一点有时候对写代码是至关重要的。

有时候想调用一个函数，想起来js里无参函数调用时可以省略后面的括号，于是就想偷懒，不写括号，结果一测试就出错，这时候根据高亮提示观察， 会发现没加括号的代码是白色的（表示属性），而加了括号的代码部分是橙色的（表示方法），所以这就提示了我这里加不加代码是两个效果。而最基本的白色主题就没有这么多的代码高亮提示，从这方面来看，还是vuesion略胜一筹。

后来将网页上的gui测试图形界面改成了按钮样式触发，虽然美中不足的是按钮独占了一个空白行（暂时还无法浮在最顶层），不过看着也还行，暂且将就一下，还是那个原则：==不要为了一点视觉上的吹毛求疵就轻易改变整个代码逻辑，尤其是自己水平还不够的情况下，这必然是一种时间与收益不成正比的行为。==

然后简单搞了一个Nginx部署，本想着在阿里云买个云服务器然后部署到Internet上的，奈何自己对流程根本不熟悉，只能退而求其次，将就着部署到localhost上，所幸能正常打开，并且亲测在没有人为干涉的情况下，能作为服务项一直在后台运行（妙啊）。